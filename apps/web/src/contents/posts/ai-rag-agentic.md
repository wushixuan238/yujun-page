---
title: "Agentic RAG"  
category: "AI"  
publishedAt: "2025-07-20"  
summary: "RAG"  
tags:  
  - AI    
banner: /images/banner/posts/ai/rag.png
alt: "图片替代文本"  
mathjax: false
---

## Agentic RAG：我的AI助理，终于学会了思考。


最近这段时间，我们估计都被RAG（检索增强生成）这个概念给刷屏了。说实话，这东西刚出来的时候，我兴奋了好一阵子。
搞个向量库，把公司的技术文档全喂进去，再接上一个大模型，一个技术问答机器人不就成了？

一开始，效果确实惊艳。但用着用着，就发现不对劲了。这哥们儿，有点“死脑筋”。

你问它：“A方法的参数是什么？” 它能搜到文档，准确地告诉你。
可你一旦换个问法，稍微复杂点：“帮我总结一下A模块和B模块的性能差异，然后把结论整理成报告。” 它立刻就懵了。

我琢磨了半天，终于找到了问题的根源。传统的RAG，它的工作流程是写死的：**检索 -> 拼接 -> 生成**。

这就是一个静态的、线性的管道。它就像一个只会用搜索引擎的实习生，你让他搜啥，他给你搜啥，然后把结果原封不动地丢给你。

可我们真正想要的，是一个能**思考并完成任务**的助理，而不是一个被动的搜索工具人。

### 破局者：Agentic RAG 的登场

就在我快要对RAG失望的时候，Agentic RAG这个概念进入了我的视野。它彻底颠覆了传统RAG的玩法，目标只有一个：**让RAG拥有主动决策和执行的能力。**

这其中的本质转变，就是把RAG从一个简单的“信息管道”，升级成了一个以**Agent**为核心的“智能决策系统”。

这个Agent，你可以把它想象成整个系统的大脑或总指挥。它有几项核心超能力：
*   **任务规划**：能把一个复杂的目标，拆解成一步步可执行的小任务。
*   **工具调用**：它的武器库里不只有向量检索，还可以调用API、访问网页、执行代码等。
*   **记忆管理**：它记得自己上一步干了什么，得到了什么结果，并基于这些信息来决定下一步该干什么。
*   **角色与目标**：你可以给它设定一个身份，比如“资深软件架构师”，它会围绕这个角色和目标去行动。

有了这个Agent大脑，整个系统的交互模式就变了。从“你问，我搜”，跃迁到了**“你提需求，我主动求解”**。这才是我们想要的那个能干活的助理。

### Agent的大脑是如何运转的？—— ReAct范式

那么，这个Agent大脑具体是怎么思考和分解任务的呢？目前主流的范式之一，就是**ReAct（Reasoning + Acting）**。

ReAct，顾名思义，就是“思考”加“行动”。它为Agent设计了一个闭环的工作流程，让它在面对一个任务时，不断地进行“思考 -> 行动 -> 观察”的循环，直到任务完成。

这听起来有点抽象，我用咱们开头那个“生成报告”的任务来举个例子，看看一个基于ReAct的Agent会怎么做：

**第一轮循环：**

*   **思考 (Thought):** 用户想让我对比A、B两个模块的性能，并生成报告。这个任务太大了，我得先拆解。第一步，我需要分别找到关于A模块和B模块的性能文档。
*   **行动 (Action):** 我决定调用`文档检索`工具，先查找“A模块性能文档”。
*   **观察 (Observation):** 工具返回了《A模块性能测试白皮书.pdf》。

**第二轮循环：**

*   **思考 (Thought):** 好的，A模块的文档找到了。现在我需要找B模块的。
*   **行动 (Action):** 继续调用`文档检索`工具，查找“B模块性能文档”。
*   **观察 (Observation):** 工具返回了《B模块压力测试报告.docx》。

**第三轮循环：**

*   **思考 (Thought):** 太棒了，两个文档都到手了。现在我需要阅读这两份文档，提取出核心的性能指标和结论，然后进行对比。
*   **行动 (Action):** 调用`文档摘要与对比`工具，输入是刚才找到的两份文档。
*   **观察 (Observation):** 工具返回了对比结果：“A模块在QPS上领先20%，但B模块的TP99延迟更低...”

**第四轮循环：**

*   **思考 (Thought):** 对比结果已经有了。最后一步，就是根据这些结果，生成一份结构化的报告。
*   **行动 (Action):** 调用`报告生成`工具，把刚才的对比分析结果作为输入。
*   **观察 (Observation):** 工具生成了一篇完整的性能对比报告。任务完成。

看到了吗？通过这个“思考-行动-观察”的循环，Agent自主地把一个复杂的任务拆解成了多个步骤，并且动态地调用不同的工具来完成每一步。这就是多阶段任务分解的核心机制。它不再是一条道走到黑的线性管道，而是一个能根据中间结果不断调整路径的智能体。

### 给Agent打造一个“瑞士军刀”—— 多源检索能力

一个再聪明的Agent，如果没有趁手的工具，也是寸步难行。在Agentic RAG里，我们不仅限于向量检索，而是要把所有可能的知识源，都封装成标准化的“工具”，放进Agent的工具箱里。

这方面，像LlamaIndex这样的框架就提供了非常强大的支持。它可以把任何东西都变成一个“工具”。

举个例子，对于一份技术文档，我们可以为它构建两种不同的索引，并封装成两个独立的工具：

1.  **向量索引 (VectorIndex)**：把文档内容切碎了做成向量。这个工具擅长回答细节问题，比如“XX方法的具体参数是什么？”。
2.  **摘要索引 (Summary Index)**：对整篇文档或各个章节做个总结。这个工具擅长回答宏观问题，比如“这篇文档的核心贡献是什么？”。

然后，我们把这两个索引分别包装成`QueryEngineTool`，注册到Agent的工具池里。

当用户提问时，Agent的“思考”环节就会分析：“嗯，这个问题是在问细节，我应该调用`向量索引`那个工具；哦，这个问题是在问总结，那我应该用`摘要索引`工具。”

这种工具化的设计，让知识的访问变得模块化和可调度。我们可以把向量库、数据库、API接口、网页搜索，甚至是你写的一个Python函数，全都变成Agent可以随时调用的工具。Agent的能力边界，就这样被无限拓宽了。

### 写在最后

从传统RAG到Agentic RAG，这不仅仅是一次技术升级，更是一次思维范式的转变。我们构建的不再是一个简单的问答机器人，而是一个具备初级推理和规划能力的自动化工作流引擎。

它让我们的AI助理，终于从一个只会“鹦鹉学舌”的查询工具，进化成了一个能理解任务、拆解问题、调用工具、最终达成目标的“问题解决者”。

当然，Agentic RAG目前也还在快速发展中，多Agent协作的复杂性、工具调用的稳定性等都还有很多挑战。但无论如何，它已经为我们打开了一扇通往更智能、更自主的AI应用的大门。那个能帮你写代码、做分析、发邮件的数字同事，或许真的离我们不远了。